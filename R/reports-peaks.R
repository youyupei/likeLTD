pack.admin.input.peaks <- function(peaksFile, refFile, caseName='dummy',databaseFile=NULL, kit=NULL, linkageFile=NULL, outputPath=getwd() ) {
	# Packs and verifies administrative information.
	# Documentation in man directory.
    	paths <- c(peaksFile, refFile) 
	if(!is.null(databaseFile)) paths <- c(databaseFile, paths, recursive=TRUE)
	if(!is.null(linkageFile)) paths <- c(linkageFile, paths, recursive=TRUE)
	for(path in paths) {
		if(!file.exists(path))
			stop(paste(path, "does not exist."))
		else { 
			info <- file.info(path)
			if(info$isdir) stop(paste(path, "is not a file."))
      		}
    		} # loop over files.
	if(file.exists(outputPath) & !file.info(outputPath)$isdir) 
	stop(paste(outputPath, " exists and is not a directory."))
	admin <- list( caseName=caseName,
                databaseFile=databaseFile,
                linkageFile=linkageFile,
                peaksFile=peaksFile,
                refFile=refFile,
                outputPath=outputPath,
		kit=kit )
	return(admin)}

locus.likes.peaks <- function(hypothesis,results,...){
	# Generate locus likelihoods from overall likelihood
	# 	hypothesis: generated by either defence.hypothesis() or 
      #     prosecution.hypothesis()
	# results: results from do.call(optim,params)
	model <- create.likelihood.vectors.peaks(hypothesis)
	arguments <- relistArguments.peaks(results$optim$bestmem, hypothesis, ...)
	likes <- do.call(model,arguments)
	likes <- likes$objectives * likes$penalties
	}


# function to check if stutter
checkStutter = function(x,alleles,heights,stutterPos=-1,upperThresh=0.15,lowerThresh=0.05)
	{
	thisIndex = which(alleles==x)
	parentIndex = which(alleles==x-stutterPos)
	if(length(parentIndex)>0)
		{
		# x>15% allelic
		if(heights[thisIndex]/heights[parentIndex]>=upperThresh) return(2)
		# 5%<x<15% uncertain
		if((heights[thisIndex]/heights[parentIndex]<upperThresh)&(heights[thisIndex]/heights[parentIndex]>=lowerThresh)) return(1)
		# x<5% = non-alleleic
		if(heights[thisIndex]/heights[parentIndex]<lowerThresh) return(0)
		} else {
		# no parent peak (not in stutter position)
		return(NA)
		}
	}
# combine stutter calls for overall call
combineStutter = function(stutterCall,doubleCall,overCall)
	{
	calls = c(stutterCall,doubleCall,overCall)
	if(any(calls==0,na.rm=TRUE)) return(0)
	if(any(calls==1,na.rm=TRUE)) return(1)
	return(2)
	}

getPeakContributors = function(locusPeaks,locusRefs)
	{
	conts = list()
	for(i in 1:length(locusPeaks))
		{
		conts[[length(conts)+1]] = which(sapply(locusRefs,FUN=function(x) any(as.numeric(x)%in%as.numeric(locusPeaks[i]))))
		}
	return(conts)
	}

plotline = function(height,size,contributors,colours)
	{
	if(length(contributors)==0) 
		{
		lines(c(size,size),c(0,height),col="black",lwd=3,lend=1)
		} else {
		# solid line
		lines(c(size,size),c(0,height),col=colours[contributors[1]],lwd=3,lend=1)
		if(length(contributors)>1)
			{
			# hexadecimal goes to 15
			max = 15
			# number of contributors at this peak
			ncont = length(contributors)
			# how large we can make each subline
			factor = floor(max/(ncont-1))
			factor = 2
			for(i in 1:(ncont-1))
				{
				# hexadecimal code for lines on/off scheme for each contributor
				lineScheme = paste(c(toString(as.hexmode((ncont-i)*factor)),toString(as.hexmode(i*factor))),collapse="",sep="")
				# plot the subline for this individual
				lines(c(size,size),c(0,height),col=colours[contributors[i+1]],lwd=3,lend=1,lty=lineScheme)
				}
			}
		}
	}

pack.genetics.for.peaks.reports = function(cspFile,refFile)
    {
    csp = read.peaks.profile(cspFile)
    refs = read.known.profiles(refFile)
    return(list(csp=csp,refs=refs))
    }

plot.CSP.heights = function(csp,refs=NULL,dbFile=NULL,kit=NULL,outputFile=NULL,toPlot=NULL,detectThresh=NULL,uncThresh=0.05,stutterThresh=0.15,doStutter=FALSE,replicate=1)
	{
	# get database
    if(is.null(dbFile)&is.null(kit)) kit = "DNA17-lus"
    alleleDb = load.allele.database(dbFile,kit)
	# get K profiles
	if(!is.null(refs)) 
		{
		Q = refs[which(unlist(refs[,1])),-1]
		# make Q the first individual
		refIndex = which(unlist(refs[,1]))
		refs = rbind(refs[refIndex,],refs[-refIndex,])
		# colours
		contColours = rainbow(nrow(refs))
		nK = length(contColours)
		cspProfile = sapply(csp$alleles,FUN=likeLTD:::convert.to.binary,simplify=FALSE)
        cspProfile = t(sapply(cspProfile,FUN=function(x) sapply(x,FUN=unlist)))
        alleleDb = likeLTD:::ethnic.database.lus(colnames(alleleDb)[5], colnames(cspProfile), alleleDb)
        alleleDb = likeLTD:::missing.alleles.peaks(alleleDb, cspProfile, refs[which(unlist(refs[,1])),-1,drop=FALSE], refs)
		}
	# locus names
	if(is.null(toPlot))
		{
		loci = rownames(csp$alleles[[replicate]])
		} else {
		loci = toPlot
		}
	# stutter calls 
	if(doStutter) 
		{
		stutters = likeLTD:::make.allelic.calls(csp,stutterThresh)
		}
	# set plotting parameters that are constant across loci
	dims = rep(ceiling(sqrt(length(loci))),times=2)
	print(range(unlist(csp$heights[[replicate]][loci,]),na.rm=TRUE))
	YLIM = c(0,range(as.numeric(unlist(csp$heights[[replicate]][loci,])),na.rm=TRUE)[2])
	YLIM = YLIM + c(0,YLIM[2]/10)
	if(!is.null(outputFile)) pdf(outputFile)
	par(mfrow=dims,mar=c(2,2,2,0.5))
	# loop over loci
	for(j in 1:length(loci))
		{
		# remove NAs
		index = which(!is.na(csp$alleles[[replicate]][loci[j],]))
		alleles = as.numeric(unlist(csp$alleles[[replicate]][loci[j],][index]))
		heights = as.numeric(unlist(csp$heights[[replicate]][loci[j],][index]))
		thisDB = alleleDb[[which(names(alleleDb)==loci[j])]]
		dbIndex = sapply(alleles,FUN=function(x) which(rownames(thisDB)==x))
		# set plotting parameters that are specific to a locus
		XLIM = range(thisDB[dbIndex,2],na.rm=TRUE)
		XLIM = XLIM + c(-2,2)
		flag = (j-1)%%dims[1]==0
		# make an empty plot
		print("plot")
		plot(NA,ylim=YLIM,xlim=XLIM,ylab="RFU",xlab="Size",main=loci[j],yaxt=ifelse(flag,'s','n'))
		# add baseline
		abline(h=0)
		# add detection threshold
		print("detectThresh")
		if(!is.null(detectThresh)) abline(h=detectThresh,col="red",lty=3)
		if(!is.null(refs))
			{
			# get which K contributes to each peak
			peakContributors = getPeakContributors(alleles,refs[,loci[j]])
			# add peaks to plot
			mapply(heights,thisDB[dbIndex,2],peakContributors,FUN=function(a,b,c) plotline(height=a,size=b,contributors=c,contColours))
			} else {
			mapply(heights,thisDB[dbIndex,2],FUN=function(a,b) lines(x=c(b,b),y=c(0,a),col="black",lwd=2))
			}
		# add peak labels to plot
		if(!doStutter)
			{
			# with no predicted stutter
			mapply(thisDB[dbIndex,2],heights,alleles,FUN=function(x,y,a) text(x,y+(YLIM[2]/12),a,col="blue"))
			} else {
			# with predicted stutter
			# stutter
			stutter = sapply(alleles,FUN=checkStutter,alleles=alleles,heights=heights)
			doubleStutter = sapply(alleles,FUN=checkStutter,alleles=alleles,heights=heights,stutterPos=-2,upperThresh=0.1)
			overStutter = sapply(alleles,FUN=checkStutter,alleles=alleles,heights=heights,stutterPos=1,upperThresh=0.1)
			calls = mapply(FUN=combineStutter,stutter,doubleStutter,overStutter)
			labelCols = vector(length=length(calls))
			certIndex = which(calls==2)
			labelCols[certIndex] = "blue"
			uncIndex = which(calls==1)
			labelCols[uncIndex] = "purple"
			labelCols[-c(certIndex,uncIndex)] = "red"
			# with predicted stutter (crude)
			mapply(thisDB[dbIndex,2],heights,alleles,labelCols,FUN=function(x,y,a,c) text(x,y+(YLIM[2]/12),a,col=c))
			}
		}		
    if(!is.null(outputFile)) dev.off()
	}

representation.and.rfu = function(K,alleles,heights,loci)
    {
    representReplicates = sapply(1:length(alleles), FUN=function(y) sapply(loci,FUN=function(x) K[[x]]%in%alleles[[y]][x,]),simplify=FALSE)
    foo = function(x) mapply(any,x)
    representOverall = do.call(foo,represented)
    representation = sum(representOverall)/length(representOverall)
    rfu = sapply(1:length(alleles), FUN=function(z) sapply(loci,FUN=function(x) sapply(K[[x]], FUN=function(y) ifelse(!y%in%alleles[[z]][x,],0,heights[[z]][x,which(alleles[[z]][x,]==y)]))))
    return(c(representation,mean(as.numeric(unlist(rfu)))))
    }


get.representation.rfu = function(csp,refs)
    {
    loci = colnames(refs)[-1]
    info = sapply(1:nrow(refs),FUN=function(x) representation.and.rfu(refs[x,-1],csp$alleles,csp$heights,loci))
    rownames(info) = c("representation","meanRFU")
    colnames(info) = rownames(refs)
    return(info)
    }

allele.report.peaks = function(admin)
    {
    # get genetics
    gen = pack.genetics.for.peaks.reports(admin$peaksFile,admin$refFile)
    # plot CSP
    sapply(1:length(gen$csp$alleles),FUN=function(x) plot.CSP.heights(csp=gen$csp,refs=gen$refs,dbFile=admin$databaseFile,kit=admin$kit,detectThresh=admin$detectThreshold,doStutter=TRUE,replicate=x))
    # representation
    repRFU = get.representation.rfu(gen$csp,gen$refs)
    # 
    

    }


