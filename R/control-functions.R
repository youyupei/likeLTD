#----------------------------------------------------
# start.values()
#----------------------------------------------------
# function to make sensible guesses for starting values for:
# do: initial drop-out
# deg: degradation
# rcont: relative contribution

# No arguments handed to this function, 
# instead it uses objects in workspace generated by GUI, 
# some objects are inhereted from inputs.RData which is loaded by GUI

# Returns starting nupa and depa 

start.values = function(){

# 1. Dropout. Uses the estimated representation of Q's alleles, for each run.
Q.K = c(nameK,nameQ)
Q.est = estimates[row.names(estimates)==nameQ,]
p.do = 1-as.numeric(Q.est[,1:nrep])/100 
# avoids start values of exactly 0 or 1
p.do[p.do==1]=0.99
p.do[p.do==0]=0.01
# for defence, crudely increases dropout for runs that Q is well represented in
d.do = (p.do+0.2)/2

# 2. Degradation. Not sure yet
p.deg = rep(0.003,nN-1)
d.deg = rep(0.003,dN-1)

# 3. Initial rcont (relative contribution)
# % representation of K. As above uses the estimated representation of K's alleles (averaged for each run)
Krcont = c(); for (n in nameK)Krcont=c(Krcont,estimates[row.names(estimates)==n,nrep+1])
# % representation of U. 
# Assumes some alleles are shared with others (Q other Us and Ks) 
# Therefore attempts to allocate max 1 unaccounted allele per locus to each U
otherBoth. = otherBoth  # copy of previous object
Urcont = numeric(NU+1) # Number of U, dropin is treated as an extra
for(U in 1:(NU+Drin)){
	U.alleles = 0
	for(n in 1:nloc){
		if (otherBoth.[n]>0){otherBoth.[n]=otherBoth.[n]-1; U.alleles=U.alleles+1}
		}
	Urcont[U]=100*U.alleles/10 # Since it can assign max 10 alleles to each U
	}
# % representation of Q. As above uses the estimated representation of K's alleles (averaged for each run)
q.est = as.numeric(Q.est[nrep+1])

# 4. decide which partial known contributors (part.) are added to rcont 
part.Krcont = Krcont[Krcont!=100] # must be less than 100% represented
part.q.est = q.est

# decide which contributor it is relative to 
rel.cont = 100
if (q.est!=100) rel.cont = q.est # relative to Q, if Q is less than 100%
if (q.est==100 & NU > 0 & Urcont[1]>0) rel.cont = Urcont[1] # relative to first U, if Q is 100%, and inital U estimate is greater than 0%
if (q.est ==100 & NU == 0 & length(part.Krcont)>0 ) rel.cont = part.Krcont[1] # relative to first K, if Q is 100% and no U

# create rcont for prosecution
p.rcont = c(part.Krcont,part.q.est,Urcont)/rel.cont
if(q.est==100)p.rcont = c(part.Krcont,NULL,Urcont)/rel.cont # leave Q out if fully represented.

# create rcont for defence
tmp = c(part.Krcont,sort(c(q.est,Urcont),decreasing=T))# concept of X (equivalent of Q) is no different to any other U, so largest must come first
d.rcont = tmp/max(tmp) 

# incorporate starting values into nupa and depa
nupa=list(L=0, l=rep(0,nloc), do=p.do, deg=p.deg, rcont=p.rcont, locadj=rep(1,nloc),best=0,better=0)
depa=list(L=0, l=rep(0,nloc), do=d.do, deg=d.deg, rcont=d.rcont, locadj=rep(1,nloc),best=0,better=0)
return(list(nupa=nupa, depa=depa))}
#----------------------------------------------------


#----------------------------------------------------
# global.objects()
#----------------------------------------------------
# function to assign various global objects.
# Some are calculated, some are simple declarations (see declarations below)

#	 Calculated:
#	 known: formatted profiles of Qs and Ks
#	 Qdrop: T or F, calculates if Q is subject to drop out
#	 Nknd: calculates 'number of knowns with no dropout'
#	 Nkdo: calculates 'number of knowns with drop out'
#	 frq: calculates adjusted allele frequencies

# No arguments handed to this function, 
# instead it uses objects in workspace generated by GUI, 
# some objects are inhereted from inputs.RData which is loaded by GUI

# No values are returned by this function,
# instead all objects are assigned globally

global.objects=function(){

# 1. Converts Queried and Known into a suitable format

index = c(); for (x in c(nameQ,nameK))index = c(index,which(rownames(REF)==x)) # the index of K in REF
known <<- as.list(onlyCSP[0,])
for(locus in 1:length(cprofs))known[[locus]] <<- strsplit(paste(REF[[locus]][index],collapse=','),',')[[1]] # converts into a vector

# 2. check for dropout from the queried profile

allCheck=0;	for(r in 1:nrep){
	check=0; for(l in 1:nloc){
		suppressWarnings(if(sum(is.na(cprofs[[l]][[r]]$csp))==0)check=check+sum(!known[[l]][1:2]%in%cprofs[[l]][[r]]$csp))
		allCheck=allCheck+check
		}}
if(allCheck==0)Qdrop<<-FALSE;if(allCheck!=0)Qdrop<<-TRUE

# 3. checks each known profile for dropout

Nknd <<- 0; Nkdo <<- 0; knownDropout=c()
if(length(known[[l]])>2)for(x in 2:(length(known[[l]])/2)){
	eachLoc=c();for(r in 1:nrep)for(l in 1:nloc)suppressWarnings(if(sum(is.na(cprofs[[l]][[r]]$csp))==0)eachLoc=c(eachLoc,!known[[l]][(x*2-1):(x*2)]%in%cprofs[[l]][[r]]$csp))
	if(sum(eachLoc)==0)Nknd<<-Nknd+1
	if(sum(eachLoc)!=0){Nkdo<<-Nkdo+1;knownDropout=c(knownDropout,x)}	
	}

# 4. Allele frequencies, based on ethnic group

frq <<- vector("list",nloc)
for(j in 1:nloc){
	marker = names(cprofs)[j]
	if(ethnic=='EA1') frq[[j]] <<- matrix(c(subset(afreq,Marker==marker)$EA1,subset(afreq,Marker==marker)$BP),,2)
	if(ethnic=='EA2') frq[[j]] <<- matrix(c(subset(afreq,Marker==marker)$EA2,subset(afreq,Marker==marker)$BP),,2)
	if(ethnic=='EA3') frq[[j]] <<- matrix(c(subset(afreq,Marker==marker)$EA3,subset(afreq,Marker==marker)$BP),,2)
	if(ethnic=='EA4') frq[[j]] <<- matrix(c(subset(afreq,Marker==marker)$EA4,subset(afreq,Marker==marker)$BP),,2)
	rownames(frq[[j]]) <<- subset(afreq,Marker==marker)$Allele
	}
# adjusted by mean fragment length for the data base

s1=0; s2=0; for(j in 1:nloc) {s1 = s1 + sum(frq[[j]][,1]*frq[[j]][,2],na.rm=T); s2 = s2 + sum(frq[[j]][,1])}
meanbp = s1/s2 # mean fragment length for the database
for(j in 1:nloc) {frq[[j]][,2] <<- frq[[j]][,2] - meanbp; frq[[j]][is.na(frq[[j]][,2]),2] <<- 0}

initiated <<- as.character(Sys.time())
BB <<-  -4.35 # slope parameter of the multi-dose dropout model, taken from  Tvederbrink et al 2009
nloc <<- length(cprofs); nrep <<- length(cprofs[[1]])
nN <<- Nkdo+Qdrop+NU+1; # numbers subject to dropout under Hp, the + 1 is for dropin (the parameter always exists but is zero if Drin=F) is modelled
nRef <<- nN - max(1,NU+Qdrop)
dN <<- Nkdo+NU+1+1 # numbers subject to dropout under Hd
dRef <<- dN - max(1,Qdrop+NU+1)
mfunpr <<- 1:2; if(Nkdo>0) mfunpr <<- c(mfunpr,2+2*Nknd+(1:(2*Nkdo)))
}
#----------------------------------------------------

#----------------------------------------------------
# propose.new()
#----------------------------------------------------
# function to propose new parameter values at each iteration, within main loop

# Arguments required are:
#	nupa: returned by this function propose.new(), or initialised by start.values()
#	depa: returned by this function propose.new(), or initialised by start.values()
#	itr: iteration between 1 and niter, updated by control
#	rcontupsd: SA parameter
#	degupsd: SA parameter
#	doupsd: SA parameter

# SA arguments(fixed):
#	Drin: Drop in. Global, set in GUI-optimised()
#	Qdrop: Drop-out from queried profile. Global, declared in global.objects()
#	NU:number of unprofiles contributors. Global, set in GUI-optimised()
#	nN: Number of profiles subject to drop-out. Global, declared in global.objects()

# Returns:
#	nupa: proposed new parameter values	
#	depa: proposed new parameter values	

propose.new = function(nupa,depa,itr,rcontupsd=0.01,degupsd=0.001,doupsd=0.01){
 
print(paste('currently processing',itr,'th iteration'))
shrink = (1-1/niter)^itr # reduce SD of parameter updates as SA algorithm progresses

# propose updates for numerator parameters
 	nupa$rcont = abs(rnorm(nN,nupa$rcont,shrink*rcontupsd)); if(!Drin) nupa$rcont[nN]=0 # new rcont values must be positive and final value must be zero if Drin=F
 	nupa$rcont[nRef] = 1 # reference individual always has rcont = 1
 	if(!Qdrop & (NU>1)) nupa$rcont[(nN-NU+1):(nN-1)]=pmin(nupa$rcont[(nN-NU+1):(nN-1)],2-nupa$rcont[(nN-NU+1):(nN-1)]) # if Q not subject to dropout and more than one unprofiled, ensure 1st of these is the largest (i.e. rcont for all others is <1)
	nupa$deg = abs(rnorm(nN-1,nupa$deg,shrink*degupsd))
 	nupa$do = pmin(1,abs(rnorm(nrep,nupa$do,shrink*doupsd))) # simulate new dropout values for ref individual, reflecting at 0 and 1
 	nupa$locadj = abs(rnorm(nloc,nupa$locadj,shrink*doupsd))
 	nupa$locadj = nupa$locadj/mean(nupa$locadj) # keep the mean locus adjustment at one
# CHANGE: added beta	
	nupa$beta = rnorm(1,nupa$beta,shrink*doupsd)
 	
# propose updates for denominator parameters
 
	depa$rcont = abs(rnorm(dN,depa$rcont,shrink*rcontupsd)); if(!Drin) depa$rcont[dN]=0
 	depa$rcont[dRef] = 1
 	if(NU+1>1)depa$rcont[(dN-NU):(dN-1)]=pmin(depa$rcont[(dN-NU):(dN-1)],2-depa$rcont[(dN-NU):(dN-1)]) # if more than one unprofiled, ensure 1st of these is the largest (all others have rcont < 1)
 	depa$deg = abs(rnorm(dN-1,depa$deg,shrink*degupsd))
 	depa$do = pmin(1,abs(rnorm(nrep,depa$do,shrink*doupsd)))
 	depa$locadj = abs(rnorm(nloc,depa$locadj,shrink*doupsd)); depa$locadj = depa$locadj/mean(depa$locadj)	
# CHANGE: added beta
	depa$beta = rnorm(1,depa$beta,shrink*doupsd)
return(list(nupa=nupa,depa=depa))}
#----------------------------------------------------

#----------------------------------------------------
# calc.L()
#----------------------------------------------------
# function to update nupa and depa with overall likelihood (L)

# Arguments required are:
#	either.pa: can be either nupa or depa, after $l has been calculated by calclik()
#	either.N: can be either nN or dN, currently assigned globally by global.objects()
#	lap: locus adjustment parameter (of the gamma prior); increase it to keep dropout rates more similar across loci 
#	Drinpen: rate of exponential penalty on Drin (increase to keep the parameters closer to zero)
#	degpen: rate of exponential penalty on deg (increase to keep the parameters closer to zero)

# Returns:
#	L:  overall likelihood	

calc.L = function(either.pa,either.N,lap=50,Drinpen=2,degpen=50){
# CHANGE: Mistake in L?
	#L = prod(either.pa$l*dgamma(either.pa$locadj,lap,lap))*exp(-Drinpen*nupa$rcont[either.N])*exp(-degpen*sum(either.pa$deg))
	bemn=-4.35
	besd=0.38
	L = prod(either.pa$l*dgamma(either.pa$locadj,lap,lap))*exp(-Drinpen*nupa$rcont[either.N]-degpen*sum(either.pa$deg))*dnorm(either.pa$beta,besd,bemn)

# bemn=-4.35
# besd=0.38
# nupa$beta (BB)=-4.35

	return(L)}
#----------------------------------------------------

#----------------------------------------------------
# prepro()
#----------------------------------------------------
# function to pre-process CSP, unc alleles and allele fractions. Called for each locus. 
# Allele counts are converted to allele fractions after removing zero count alleles, 
# then adding alleles in CSP or Qgen that are missing, and then making fst and sampling adjustments.

# Arguments required are:
# Qdr:	Different for pros and def if Q is not subject to dropout. Indicates whether alleles of the queried contributor Q are subject to dropout (NB since V4.2 this has been automatically set in the wrapper where the variable is called Qdrop, in earlier versions the user had to set this value).
# kpnd:	a vector of even length; the first two entries form the genotype of Q, duplicate entry for homozygotes, each entry a character string, "7" or "9.3".  The alleles of Q are subject to sampling and fst adjustments and must be included in afbp. Entries (2*i-1,2*i) for i>1, if any, specify the genotype of a profiled full contributor of DNA (i.e. no dropout) to the CSP; these alleles need not be in afbp as their population fractions are not required; they are removed from the CSP and included in unc, an error is generated if any of them is not observed in the CSP.
# call: 	a list of lists.  The length of the outer list is the number of replicates, nrep; there is no upper limit, but nrep must be the same for each locus (not checked), which can be achieved artificially if needed by specifying NULL replicates.  Each inner list is of length 2: [[1]] alleles of crime scene profile (CSP) alleles; [[2]] uncertain alleles (unc) - this list should include allelic positions at which there is substantial uncertainty whether or not a CSP allele is present.  The uncertainty may be caused by low peak height, or stutter or other artefact that could mask a low-level allele.  If CSP and unc have any allele in common an error message is generated and zero is returned.
# acbp:	matrix with two columns: 1) database counts of alleles at the locus; 2) fragment length in bp, positive and negative values allowed and the average (however measured) should be close to zero.  The rownames must be the allele names using the same notation as used for the alleles specified in the input file, i.e. in definitions of cprofs and known 
# adj:	sampling adjustment applied to the alleles of Q to avoid very low counts for rare alleles, and to allow for the allele counts to take into account the genotype of Q.  The default value is adj = 1; there are reasons to prefer adj = 2 but the value of adj is much less important than Fst (see below) unless the database size is very small. 
# fst:	allows for shared ancestry of Q with X. Recommended that Fst should be at least 0.02, and may need to be as high as 0.05 in some populations (e.g. small, isolated subpopulations of the population from which the reference database has been drawn).

# Returns:
# csp:	matrix of indicators of CSP alleles, 1 row per replicate. Different for pros and def if Q is not subject to dropout.
# unc:	matrix of indicators of uncertain alleles, 1 row per replicate. Different for pros and def if Q is not subject to dropout.
# af:		allele frequencies, adjusted

prepro = function(Qdr,kpnd,call,acbp,adj=1,fst=0.02){

acbp = acbp[acbp[,1]>0,] # remove any zero-frequency alleles
Qgen = kpnd[1:2]; if(Qdr) kpnd = kpnd[-(1:2)]
for(i in 1:2) if(sum(rownames(acbp)==Qgen[i])==0) {acbp = rbind(c(1,0),acbp); rownames(acbp)[1] = Qgen[i]}  # if allele of Q is not in database, insert it with count 1 and set the fragment length to 0
nrep = length(call)
CSP = matrix(0,nrep,nrow(acbp)) # matrix of indicators of CSP alleles, 1 row per replicate
unc = matrix(0,nrep,nrow(acbp)) # matrix of indicators of uncertain alleles, 1 row per replicate
for(z in 1:nrep) if(length(call[[z]])>1){ # this condition checks that the replicate is not missing at the locus
	if(length(setdiff(kpnd,call[[z]][[1]])) != 0) {print(paste("Error: non-dropout allele not observed in CSP; CSP = ",call[[z]][[1]]," non-dropout alleles = ",kpnd)); return(NULL)} # check if there's a contributor wrongly labelled as non-dropout
	tmp = setdiff(call[[z]][[1]],kpnd) # CSP alleles not attributable to profiled non-dropout contributors.
	if(length(tmp)) for(i in 1:length(tmp)){
		if(sum(rownames(acbp) == tmp[i]) == 0) {  # if CSP allele is not in database, insert it with count 1 and fragment length 0
			CSP = cbind(rep(0,nrep),CSP); unc = cbind(rep(0,nrep),unc); acbp = rbind(c(1,0),acbp); rownames(acbp)[1] = tmp[i]
			}
		CSP[z,] = CSP[z,] + (rownames(acbp) == tmp[i]) # encode CSP alleles
		}
	if(length(kpnd)) for(i in 1:length(kpnd)) unc[z,] = unc[z,] + (rownames(acbp) == kpnd[i]) # non-dropout alleles are coded as uncertain because they can mask the allele of an unprofiled contributor
	tmp = call[[z]][[2]]
	if(length(tmp)) for(i in 1:length(tmp)) unc[z,] = unc[z,] + (rownames(acbp) == tmp[i]) # uncertain alleles from input file
	} 
else CSP[z,1] = 999 # flags missing replicate 
if(sum(CSP*unc)) {print(paste("Error: an allele is both uncertain and in CSP; call = ",call)); return(NULL)}
	
# The sampling adjustment, double sampling adjustment for homozygotes
acbp[Qgen,1] = acbp[Qgen,1]+adj*(1+(Qgen[1]==Qgen[2])); acbp[,1] = acbp[,1]/sum(acbp[,1])  

# fst adjustment, after adjustment acbp[,1] still sums to 1
acbp[,1] = acbp[,1]*(1-fst)/(1+fst); acbp[,1][Qgen] = acbp[,1][Qgen] + (1+(Qgen[1]==Qgen[2]))*fst/(1+fst)  
	
return(list(csp=CSP,unc=unc,af=acbp))}
#----------------------------------------------------

#-----------------------------------------
# calc.fixed()
#-----------------------------------------
# Calculates all objects that vary by locus, but fixed by iteration. Differs for pros and def.

# Arguments required are:
#	Nkdo: Number of knowns subject to dropout. Set in global.objects()
#	Nunp: number of unprofiled contributors, either NU (pros) or NU+1 (def). Set in GUI
#	afbp: Adjusted allele fractions and allele lengths. Use af from prepro()
#	kpdo: known alleles. Use known[[j]][mfunpr]. known and mfunpr from global.objects()
#	CSP: CSP for all replicates. Use csp from prepro(). Different for pros and def if Q is not subject to dropout.
#	DI: DI probability (used to determine whether to use Ureq or not), from Drin. Set in GUI.
#	Qcont:  Use 0 for def, or Qdrop or 1+Qdrop for pros. Set in global.objects(). 0 if Q is not assumed to be a contributor (i.e. under Hd), =1 if Q is a contributor not subject to dropout and =2 if Q is a contributor subject to dropout.

# Returns:
#	hyptadinit: a vector of allele doses from profiled contributors. 
#	pUall: Generates all the permutations of genotypes for the unprofiled contributors.
#	tprof: a matrix of allele doses from profiled contributors.
#	index: internal abstraction
#	fragments: matrix of fragment lengths across all permutations
#	v.index: Internal abstraction required to index specific elements in tprof matrix.

calc.fixed = function(Nkdo,Nunp,afbp,kpdo,CSP,DI,Qcont){

	# generates hyptadinit
	ind = rep((1:Nunp),rep(2,Nunp))  # ind = c(1,1,2,2,3,3) when Nunp=3
	Qgen=kpdo[1:2];kpdo=kpdo[-(1:2)];if(Qcont==2)kpdo=c(kpdo,Qgen) # if Q is contributor subject to dropout, put those alleles last in kpdo 
	hyptadinit=rep(0,nrow(afbp))
	if(length(kpdo)) for(u in 1:length(kpdo))hyptadinit = hyptadinit +(rownames(afbp)==kpdo[u])

	# generates pUall
	if(nrep>1) CSPset = colSums(CSP[CSP[,1]<999,])>0  else CSPset = CSP # T for alleles that occur in CSP at least once

if (DI==0) {
		Ureq = which((CSPset * (hyptadinit == 0)) > 0)  # identify alleles in CSP but not in kpdo, so must come from the U or X
		nUx =  2*Nunp - length(Ureq)} else {nUx <- 2*Nunp}
		if(nUx < 0) {return(0)} else if(nUx > 0) {Ux = combinations(nrow(afbp),nUx,rep=T)} else {Ux = matrix(0,1,0)} 
		pUall.end <- matrix(data=c(rep(0, times=2*Nunp)),ncol=2*Nunp)
		for(j in 1:nrow(Ux)){  # all possible allocations of required + random alleles to the unprofileds
			if (DI==0){pUall =
				if(length(unique(c(Ureq,Ux[j,])))==(2*Nunp)) {permutations(2*Nunp,2*Nunp,c(Ureq,Ux[j,]),set=F)} else {unique(permutations(2*Nunp,2*Nunp,c(Ureq,Ux[j,]),set=F))}
				}
			else {pUall = 
				if(length(unique(Ux[j,]))==(2*Nunp)) {permutations(2*Nunp,2*Nunp,Ux[j,],set=F)}else {unique(permutations(2*Nunp,2*Nunp,Ux[j,],set=F))} 
				}
			
			pUall = pUall[which(apply(pUall[,2*(1:Nunp)-1,drop=F]<=pUall[,2*(1:Nunp),drop=F],1,prod)>0),,drop=F]
			pUall.end <- rbind(pUall.end,pUall)
			}
	pUall <- pUall.end[-1,]


# CHANGE: edit pUall
if(is.matrix(pUall)==FALSE) pUall <- t(as.matrix(pUall))

	# generates other fixed values
	N = dim(pUall)[1] # number of genotypes 
	tprof = matrix(hyptadinit,ncol=N,nrow=length(hyptadinit),byrow=F) # doses from known contributors
	index = Nkdo+ind
	fragments = t(matrix(afbp[pUall,2],nrow=N))
	v.index = (0:(N-1))*length(hyptadinit)

return(list(hyptadinit=hyptadinit,pUall=pUall,tprof=tprof,index=index,fragments=fragments,v.index=v.index))}
#-----------------------------------------

#-----------------------------------------
# prod.matrix() 
#-----------------------------------------
# Fast method for calculating the product of rows in a matrix
# Called for each locus, for each iteration, within Calclik.1() and Adjust.Like()

# Arguments required are:
# 	Any matrix

prod.matrix=function(x){
	y=x[,1]
	for(i in 2:dim(x)[2])
	y=y*x[,i]
return(y)}
#-----------------------------------------

#-----------------------------------------
# Calclik.1() core likelihood computation, optimised to handle arrays 
#-----------------------------------------
# Calculates likelihoods,called for each locus, for each iteration.

# Arguments required are:
#	kpdo: Known profiles subject to drop out. Use known[[j]][mfunpr] from global.objects()
#	DO: Drop-out. Different for pros or def. Use nupa$do or depa$do from either propose.new(), or initialised by start.values()
#	DI: Drop-in T or F (used to determine whether to use Ureq or not). Use Drin from GUI 
#	afbp: allele fractions and allele lengths. Use nu[[j]]$af from calc.fixed().
#	CSP: CSP for all replicates. Different for pros and def. Use nu[[j]]$csp or de[[j]]$csp from calc.fixed()
#	unc: Uncertain alleles. Use nu[[j]]$unc or de[[j]]$unc from calc.fixed()
#	nrep: number of replicates, from global.objects()
#	BB: vector containing two objects, 1) local adjustment nupa$locadj[[j]] from start.values(). 2) Tvederbrink constant BB from global.objects()
#	pUall: a matrix of every permutation of possible genotypes. Use nu[[j]]$pUall or de[[j]]$pUall from calc.fixed()
#	Nunp: Number of unprofiled contributors. Use NU for pros and NU+1 for defence, set in GUI.
#	rcont: Relative contribution. Use nupa$rcont or depa$rcont,from either propose.new(), or initialised by start.values()
#	deg: Degradation parameter. Use 1+nupa$deg or 1+depa$deg, from either propose.new(), or initialised by start.values()
#	tprof: doses from known contributors. Use nu[[j]]$tprof or de[[j]]$tprof from calc.fixed()
#	index: internal abstraction. Use nu[[j]]$index or de[[j]]$index from calc.fixed()
#	fragments: matrix of fragment lengths across all permutations. Use nu[[j]]$fragments or de[[j]]$fragments from calc.fixed()
#	v.index: Internal abstraction required to index specific elements in tprof matrix. Use nu[[j]]$v.index or de[[j]]$v.index from calc.fixed()

# returns the likelihood

Calclik.1 = function(kpdo,DO,DI,afbp,CSP,unc,nrep,BB,pUall,Nunp,rcont,deg,tprof,index,fragments,v.index){

if(length(kpdo)) for(u in 1:length(kpdo)){
	vec = (rownames(afbp)==kpdo[u])
	if(sum(vec)) tprof = tprof + vec*deg[trunc((u+1)/2)]^-afbp[kpdo[u],2]*rcont[trunc((u+1)/2)] # the allele dose from a profiled contributor is the corresponding element of rcont times deg (degradation parameter) for that contributor raised to the power of -fragment length
	} 

tmp = deg[index]^-fragments * rcont[index] # doses for U/X
for(u in 1:(2*Nunp)){ # for each contributor (2 alleles each).Loop required to sum contributions at the same allele
	tprof[pUall[,u]+ v.index] = tprof[pUall[,u]+ v.index] + tmp[u,]
	}

N = dim(tprof)[2] # size of array 
zero = !tprof # used in index.4 and index.5, avoids redundancy 
af.4 = af.5 = matrix(afbp[,1], nrow =N,ncol=length(afbp[,1]),byrow=T) # matrix allele freqs 
tmp = t(tprof*BB[1])^BB[2] # Tvederbrink adjustment 
drpin =  DI*(1-DO) # dropin rate
term.1 = 1 # product of 4 types of contribution
for(z in 1:nrep) if(CSP[z,1]!=999){ # check for missing replicate. Loop required for each replicate
	tmp.1 = tmp*DO[z] # 0.22 avoids redundancy of calculating twice
	vdosedr = tmp.1/(tmp.1+1-DO[z]) # 0.64 drop-out probabilities for doses 
	
	term.2 = vdosedr[,!CSP[z,] & !unc[z,]] # 0.44 contribution from dropout 
	if(!is.matrix(term.2))term.2=1;if(is.matrix(term.2)){	# only calculates product of rows if there are values
	term.2[c(is.nan(term.2))] = 1 # 1.04 replaces NaNs with 1
	term.2 = prod.matrix(term.2)} # 0.58 product of each row

	if(sum(CSP[z,])==0)term.3=1; if(sum(CSP[z,])!=0){ # avoids trying to calc product of blank matrix if CSP[z,])==0
	term.3 = 1-vdosedr[,CSP[z,]!=0] # 0.12 contribution from non-dropout
	if(!is.matrix(term.3))term.3=1;if(is.matrix(term.3)){	# only calculates product of rows if there are values
	term.3[c(is.nan(term.3))] = 1 # 0.21 replaces NaNs with 1
	term.3 = prod.matrix(term.3)}} # 0.13 product of each row

	if(DI==0)term.4=1; if(DI!=0){ # only necessary if drop-in is modelled
	index.4 = t(CSP[z,] & zero) # 1.28 contribution from drop-in 
	term.4 = drpin[z] * af.4  # 0.22
	if(!is.matrix(term.4))term.4=1;if(is.matrix(term.4)){	# only calculates product of rows if there are values
	term.4[!index.4] = 1 # 1.52 replaces indexed values with 1
	term.4 = prod.matrix(term.4)}} # 0.72 product of each row 
	
	if(DI==0)term.5=1; if(DI!=0){ # only necessary if drop-in is modelled
	index.5 = t(!CSP[z,]&!unc[z,]& zero) # 1.31 contribution from non-dropin 
	term.5 = 1-drpin[z] * af.5 # 0.44
	if(!is.matrix(term.5))term.5=1;if(is.matrix(term.5)){	# only calculates product of rows if there are values
	term.5[!index.5] = 1 # 1.25 replaces indexed values with 1
	term.5 = prod.matrix(term.5)}} # 0.70 product of each row 

	term.1 = term.1*term.2*term.3*term.4*term.5 # 0.09
	}
return(term.1)}
#-----------------------------------------

#-----------------------------------------
# Adjust.Like()
#-----------------------------------------
# Adjusts the likelihood array for relatedness, allele frequency, and homozygocity.
# Called for each locus, for each iteration.

# Arguments required are:
# 	like.array: an array of likelihoods produced by Calclik.1().(Varies across loci, varies across iterations)
#	pUall: a matrix of every permutation of possible genotypes. Use nu[[j]]$pUall or de[[j]]$pUall from calc.fixed()
#	afbp: allele fractions and allele lengths. Use nu[[j]]$af from calc.fixed().
#	Nunp: Number of unprofiled contributors. Use NU for pros and NU+1 for defence, set in GUI.
#	rel: Relatedness coefficient. Set in wrapper as rr

# Returns the adjusted final likelihood

Adjust.Like <- function(like.array,pUall,afbp,Nunp,rel) {
	het <- 1+(pUall[,2*(1:Nunp)-1]<pUall[,2*(1:Nunp)]) # homozygocity adjustment
	if (Nunp>1) het <- prod.matrix(het) # multiple homozygocity adjustments if Nunp=3
	fraction <- matrix(data=afbp[pUall[,],1], ncol=ncol(pUall)) # set allele frequencies
	fraction <- prod.matrix(fraction) # allele frequency adjustment
	endlike <- like.array*fraction*het # apply adjustments to likelihoods
	# endlike <- endlike * rel[1]/2 # adjust for relatedness
	like <- sum(endlike)
	return(like)
	}
# ---------------------------------------

#-----------------------------------------
# decide()
#-----------------------------------------
# Evaluates the likelihood results from latest proposed parameters
# Decides whether to accept new proposed parameters or stick with old ones.
# If a better maximum likelihood is found, maxn and maxd are updated
# Parameters are updated with a count of how many times the maximum likelihood improved.
# All evaluation done for pros and def separately

# Arguments required are:
#	depa.old: last accepted def parameters
#	nupa.old: last accepted pros parameters
#	depa: new proposed def parameters
#	nupa: new proposed pros parameters
#	itr: iteration between 1 and niter, updated by control

# Returns either the new or old parameters of nupa and depa
# Globally updates maxn or maxd

decide = function(depa.old,nupa.old,depa,nupa,itr){

temp = (1-itr/niter)^3 # rate of cooling in annealing process. As itr increases, less chance of poorer parameters being accepted

if(nupa$L <= 0 | exp((nupa$L/nupa.old$L-1)/temp) < runif(1)) nupa = nupa.old else if(nupa$L > maxn$L){nupa$best=itr; nupa$better=nupa$better+1; maxn <<- nupa}
if(depa$L <= 0 | exp((depa$L/depa.old$L-1)/temp) < runif(1)) depa = depa.old else if(depa$L > maxd$L){depa$best=itr; depa$better=depa$better+1; maxd <<- depa}

return(list(nupa=nupa,depa=depa))}
#----------------------------------------


#-----------------------------------------
# ideal()
#-----------------------------------------
# Calculates idealised likelihood assuming Q is perfect match
# Uses global arguments
# Returns a single overall likelihood

ideal = function(){
ideal.match = 1; for(j in 1:nloc){
	af = nu[[j]]$af; kn = known[[j]]; p1 = af[row.names(af)==kn[1],1]; p2 = af[row.names(af)==kn[2],1]
	ideal.match = ideal.match/(rr[2] + rr[1]*(p1+p2)/2 + (1-sum(rr))*p1*p2*(1+(kn[1]!=kn[2])))
	}
return(ideal.match)}
#----------------------------------------
		
#-----------------------------------------
# calc.all.dropouts()
#-----------------------------------------
# Calculates dropout rates for every contributor subject to dropout and for every replicate
# Uses global arguments
# Returns a matrix for def and a matrix for pros

calc.all.dropouts = function(){
hpdrout = matrix(0,nN-1,nrep); hddrout = matrix(0,dN-1,nrep)
if(nN>1) for(x in 1:(nN-1)) for(z in 1:nrep) hpdrout[x,z] = maxn$do[z]/(maxn$do[z]+maxn$rcont[x]^-BB*(1-maxn$do[z]))
if(dN>1) for(x in 1:(dN-1)) for(z in 1:nrep) hddrout[x,z] = maxd$do[z]/(maxd$do[z]+maxd$rcont[x]^-BB*(1-maxd$do[z]))
return(list(hpdrout=hpdrout,hddrout=hddrout))}
#----------------------------------------	







